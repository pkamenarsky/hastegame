// Autogenerated from c:\temp\pplarrays.xml
// DO NOT EDIT THIS FILE! Edit c:\temp\pplarrays.xml instead

#include <string>
#include "pplprograms.h"
#include "../video/programarray.hh"

struct Programentry {
	const char* m_Name,*m_Format,*m_Entrypoint,*m_Code;
};

static const Programentry s_Entries_pplvp[]={
	{"pplcg_vp","cg_vprogram","vs_main",
" \
float4x4 matWorldViewProjection; \
float3 lightpos; \
float2 fogvalues; \
 \
struct VS_INPUT  \
{ \
   float4 Position : POSITION0; \
   float3 Normal : NORMAL; \
   float2 UV : TEXCOORD0; \
}; \
 \
struct VS_OUTPUT  \
{ \
   float4 Position : POSITION0; \
   float2 UV : TEXCOORD0; \
   float3 Normal : TEXCOORD1; \
   float4 Lightvec : TEXCOORD2; \
   float Fog: FOG; \
}; \
 \
VS_OUTPUT vs_main( VS_INPUT Input ) \
{ \
   float3 dist=lightpos-Input.Position.xyz; \
   VS_OUTPUT Output; \
   Output.Position = mul( matWorldViewProjection, Input.Position ); \
   Output.Fog = 1.0f-((Output.Position.z-fogvalues.x)/fogvalues.y); \
   Output.Normal = Input.Normal; \
   Output.Lightvec = float4(dist,length(dist)); \
   Output.UV=Input.UV; \
 \
   return( Output ); \
} \
		"
	},
	{0,0,0,0}
};

static const Programentry s_Entries_pplfp[]={
	{"pplcg_fp","cg_fprogram","ps_main",
" \
sampler2D diffuseTex; \
float4 colorAndRadius; \
 \
float4 ps_main( \
   float2 UV:TEXCOORD0, \
   float3 Normal:TEXCOORD1, \
   float4 Lightvec : TEXCOORD2) : COLOR0 \
{ \
   float3 n=normalize(Normal); \
   float3 l=normalize(Lightvec.xyz); \
   float3 col=tex2D(diffuseTex,UV)*colorAndRadius.xyz; \
    \
	float ndotl=clamp(dot(n,l),0,1)*clamp( 1.0f-length(Lightvec.xyz) / colorAndRadius.w,0,1); \
 \
 return( float4( col*ndotl, 1.0f ) ); \
    \
} \
		"
	},
	{0,0,0,0}
};

PPLPrograms::PPLPrograms(ion::video::Videodevice &rVideodevice)
{
	m_pProgramarray_pplvp=new ion::video::Programarray(rVideodevice,ion::video::Programarray::Vertexprograms);
	{
		const Programentry* pEntry=&s_Entries_pplvp[0];
		for (;pEntry->m_Name!=0;++pEntry) {
			m_pProgramarray_pplvp->addProgram(pEntry->m_Name,pEntry->m_Entrypoint,pEntry->m_Code,pEntry->m_Format);
		}
	}
	m_pFirstWorkingProgram_pplvp=m_pProgramarray_pplvp->getFirstValidProgram();

	m_pProgramarray_pplfp=new ion::video::Programarray(rVideodevice,ion::video::Programarray::Fragmentprograms);
	{
		const Programentry* pEntry=&s_Entries_pplfp[0];
		for (;pEntry->m_Name!=0;++pEntry) {
			m_pProgramarray_pplfp->addProgram(pEntry->m_Name,pEntry->m_Entrypoint,pEntry->m_Code,pEntry->m_Format);
		}
	}
	m_pFirstWorkingProgram_pplfp=m_pProgramarray_pplfp->getFirstValidProgram();

}

PPLPrograms::~PPLPrograms()
{
	delete m_pProgramarray_pplvp;
	delete m_pProgramarray_pplfp;
}


PPLPrograms::PPLPrograms(const PPLPrograms& src) {}
PPLPrograms& PPLPrograms::operator =(const PPLPrograms& src) { return *this; }

ion::video::Programarray& PPLPrograms::programarray_pplvp()
{
	return *m_pProgramarray_pplvp;
}

const ion::video::Programarray& PPLPrograms::programarray_pplvp() const
{
	return *m_pProgramarray_pplvp;
}

ion::video::Program* PPLPrograms::firstWorkingProgram_pplvp()
{
	return m_pFirstWorkingProgram_pplvp;
}

const ion::video::Program* PPLPrograms::firstWorkingProgram_pplvp() const
{
	return m_pFirstWorkingProgram_pplvp;
}

ion::video::Programarray& PPLPrograms::programarray_pplfp()
{
	return *m_pProgramarray_pplfp;
}

const ion::video::Programarray& PPLPrograms::programarray_pplfp() const
{
	return *m_pProgramarray_pplfp;
}

ion::video::Program* PPLPrograms::firstWorkingProgram_pplfp()
{
	return m_pFirstWorkingProgram_pplfp;
}

const ion::video::Program* PPLPrograms::firstWorkingProgram_pplfp() const
{
	return m_pFirstWorkingProgram_pplfp;
}

