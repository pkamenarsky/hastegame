// Autogenerated from prepassarrays.xml
// DO NOT EDIT THIS FILE! Edit prepassarrays.xml instead

#include <string>
#include "depthprepassprograms.h"
#include "../video/programarray.hh"

struct Programentry {
	const char* m_Name,*m_Format,*m_Entrypoint,*m_Code;
};
//d3d_hlsl_vs20
static const Programentry s_Entries_prepassvp[]={
	{"ambient_vp","cg_vprogram","main",
" \
float4x4 matViewProjection; \
float2 fogvalues; \
 \
struct VS_OUTPUT  \
{ \
   float4 Position : POSITION0; \
   float2 UV : TEXCOORD0; \
   float3 Color : COLOR0; \
   float Fog: FOG; \
}; \
 \
VS_OUTPUT main( float4 Position : POSITION0, float2 UV:TEXCOORD0, float3 Color: COLOR0 ) \
{ \
   VS_OUTPUT Output; \
   Output.Position = mul( matViewProjection, Position );    \
   Output.Fog = 1.0f-((Output.Position.z-fogvalues.x)/fogvalues.y); \
   Output.UV=UV; \
   Output.Color=Color; \
   return( Output ); \
} \
		"
	},
	{0,0,0,0}
};
//d3d_hlsl_ps20
static const Programentry s_Entries_prepassfp[]={
	{"ambient_fp","cg_fprogram","main", 
"  \
float3 ambientcolor; \
sampler2D ambienttex; \
float4 main(float2 UV : TEXCOORD0,float3 Color: COLOR0) : COLOR0 { \
   float3 c=tex2D(ambienttex,UV); return float4(c * ambientcolor, 1.0f ); \
} \
		"
	},
	{0,0,0,0}
};

//   float3 c=tex2D(ambienttex,UV); return float4( ambientcolor*c*Color, 1.0f );


DepthPrepassPrograms::DepthPrepassPrograms(ion::video::Videodevice &rVideodevice)
{
	m_pProgramarray_prepassvp=new ion::video::Programarray(rVideodevice,ion::video::Programarray::Vertexprograms);
	{
		const Programentry* pEntry=&s_Entries_prepassvp[0];
		for (;pEntry->m_Name!=0;++pEntry) {
			m_pProgramarray_prepassvp->addProgram(pEntry->m_Name,pEntry->m_Entrypoint,pEntry->m_Code,pEntry->m_Format);
		}
	}
	m_pFirstWorkingProgram_prepassvp=m_pProgramarray_prepassvp->getFirstValidProgram();

	m_pProgramarray_prepassfp=new ion::video::Programarray(rVideodevice,ion::video::Programarray::Fragmentprograms);
	{
		const Programentry* pEntry=&s_Entries_prepassfp[0];
		for (;pEntry->m_Name!=0;++pEntry) {
			m_pProgramarray_prepassfp->addProgram(pEntry->m_Name,pEntry->m_Entrypoint,pEntry->m_Code,pEntry->m_Format);
		}
	}
	m_pFirstWorkingProgram_prepassfp=m_pProgramarray_prepassfp->getFirstValidProgram();

}

DepthPrepassPrograms::~DepthPrepassPrograms()
{
	delete m_pProgramarray_prepassvp;
	delete m_pProgramarray_prepassfp;
}


DepthPrepassPrograms::DepthPrepassPrograms(const DepthPrepassPrograms& src) {}
DepthPrepassPrograms& DepthPrepassPrograms::operator =(const DepthPrepassPrograms& src) { return *this; }

ion::video::Programarray& DepthPrepassPrograms::programarray_prepassvp()
{
	return *m_pProgramarray_prepassvp;
}

const ion::video::Programarray& DepthPrepassPrograms::programarray_prepassvp() const
{
	return *m_pProgramarray_prepassvp;
}

ion::video::Program* DepthPrepassPrograms::firstWorkingProgram_prepassvp()
{
	return m_pFirstWorkingProgram_prepassvp;
}

const ion::video::Program* DepthPrepassPrograms::firstWorkingProgram_prepassvp() const
{
	return m_pFirstWorkingProgram_prepassvp;
}

ion::video::Programarray& DepthPrepassPrograms::programarray_prepassfp()
{
	return *m_pProgramarray_prepassfp;
}

const ion::video::Programarray& DepthPrepassPrograms::programarray_prepassfp() const
{
	return *m_pProgramarray_prepassfp;
}

ion::video::Program* DepthPrepassPrograms::firstWorkingProgram_prepassfp()
{
	return m_pFirstWorkingProgram_prepassfp;
}

const ion::video::Program* DepthPrepassPrograms::firstWorkingProgram_prepassfp() const
{
	return m_pFirstWorkingProgram_prepassfp;
}

