// Autogenerated from e:\home_dv\dot3arrays.xml
// DO NOT EDIT THIS FILE! Edit e:\home_dv\dot3arrays.xml instead

#include <string>
#include "dot3programs.h"
#include "../video/programarray.hh"

struct Programentry {
	const char* m_Name,*m_Format,*m_Entrypoint,*m_Code;
};

static const Programentry s_Entries_dot3vp[]={
	{"dot3vp_vp","cg_vprogram","main",
" \
float4x4 matWorldViewProjection;  \
float3 vViewPosition; \
float3 lightpos;  \
float2 fogvalues;  \
  \
struct VS_INPUT   \
{  \
   float4 Position : POSITION0;  \
   float3 Normal : NORMAL;  \
   float2 UV : TEXCOORD0; \
   float3 Tangent : TEXCOORD1; \
   float3 Binormal : TEXCOORD2; \
};  \
  \
struct VS_OUTPUT   \
{  \
   float4 Position : POSITION0;  \
   float2 UV : TEXCOORD0;  \
   float4 Lightvec : TEXCOORD1; \
   float3 Viewvec :  TEXCOORD2; \
   float Fog: FOG;  \
};  \
  \
VS_OUTPUT main( VS_INPUT Input )  \
{ \
	VS_OUTPUT Output; \
 \
   Output.Position = mul( matWorldViewProjection, Input.Position ); \
   Output.Fog = 1.0f-((Output.Position.z-fogvalues.x)/fogvalues.y);  \
   Output.UV = Input.UV; \
   float3x3 nm = float3x3(matWorldViewProjection); \
 \
   float3x3 texspace=float3x3(Input.Tangent,Input.Binormal,Input.Normal); \
 \
   float3 lightvector=(lightpos-Input.Position ); \
   float lightveclength=length(lightvector); \
 \
   Output.Lightvec=float4(mul(texspace,lightvector),lightveclength); \
   Output.Viewvec=mul(texspace,(vViewPosition-Input.Position.xyz)); \
    \
 \
   return( Output );  \
} \
		"
	},
	{0,0,0,0}
};

static const Programentry s_Entries_dot3fp[]={
	{"dot3vp_fp","cg_fprogram","main",
" \n\
sampler2D diffuseTex;  \n\
sampler2D normalMap; \n\
float4 colorAndRadius; \n\
float4 specularColorAndPower; \n\
  \n\
float4 main(  \n\
   float2 UV:TEXCOORD0,  \n\
   float4 Lightvec : TEXCOORD1, \n\
   float3 Viewvec :  TEXCOORD2) : COLOR0  \n\
{  \n\
   float3 color=tex2D(diffuseTex,UV); \n\
   float4 normal=tex2D(normalMap,UV); \n\
   normal.xyz=normal.xyz*2.0f-1.0f; \n\
 \n\
	float lightveclen=length(Lightvec.xyz); \n\
   float3 lightvec=Lightvec.xyz/lightveclen; \n\
   float3 viewvec=normalize(Viewvec); \n\
   float3 n=normalize(normal.xyz); \n\
 \n\
   float fd=clamp(dot(lightvec,n),0,1); \n\
   float fs=pow(clamp(dot(normalize(lightvec+viewvec),n),0,1),specularColorAndPower.w); \n\
   float att=clamp( 1.0f-lightveclen / colorAndRadius.w,0,1); \n\
 \n\
   return( float4((fd*color*colorAndRadius.xyz+fs*normal.w*((fd>0) ? 1 : 0)*specularColorAndPower.xyz)*att, 1.0f ) );  \n\
   //return float4(fd,fd,fd,1); \n\
   //return float4(fs*normal.w,fs*normal.w,fs*normal.w,1); \n\
} \n\
		"
	},
	{0,0,0,0}
};

DOT3Programs::DOT3Programs(ion::video::Videodevice &rVideodevice)
{
	m_pProgramarray_dot3vp=new ion::video::Programarray(rVideodevice,ion::video::Programarray::Vertexprograms);
	{
		const Programentry* pEntry=&s_Entries_dot3vp[0];
		for (;pEntry->m_Name!=0;++pEntry) {
			m_pProgramarray_dot3vp->addProgram(pEntry->m_Name,pEntry->m_Entrypoint,pEntry->m_Code,pEntry->m_Format);
		}
	}
	m_pFirstWorkingProgram_dot3vp=m_pProgramarray_dot3vp->getFirstValidProgram();

	m_pProgramarray_dot3fp=new ion::video::Programarray(rVideodevice,ion::video::Programarray::Fragmentprograms);
	{
		const Programentry* pEntry=&s_Entries_dot3fp[0];
		for (;pEntry->m_Name!=0;++pEntry) {
			m_pProgramarray_dot3fp->addProgram(pEntry->m_Name,pEntry->m_Entrypoint,pEntry->m_Code,pEntry->m_Format);
		}
	}
	m_pFirstWorkingProgram_dot3fp=m_pProgramarray_dot3fp->getFirstValidProgram();

}

DOT3Programs::~DOT3Programs()
{
	delete m_pProgramarray_dot3vp;
	delete m_pProgramarray_dot3fp;
}


DOT3Programs::DOT3Programs(const DOT3Programs& src) {}
DOT3Programs& DOT3Programs::operator =(const DOT3Programs& src) { return *this; }

ion::video::Programarray& DOT3Programs::programarray_dot3vp()
{
	return *m_pProgramarray_dot3vp;
}

const ion::video::Programarray& DOT3Programs::programarray_dot3vp() const
{
	return *m_pProgramarray_dot3vp;
}

ion::video::Program* DOT3Programs::firstWorkingProgram_dot3vp()
{
	return m_pFirstWorkingProgram_dot3vp;
}

const ion::video::Program* DOT3Programs::firstWorkingProgram_dot3vp() const
{
	return m_pFirstWorkingProgram_dot3vp;
}

ion::video::Programarray& DOT3Programs::programarray_dot3fp()
{
	return *m_pProgramarray_dot3fp;
}

const ion::video::Programarray& DOT3Programs::programarray_dot3fp() const
{
	return *m_pProgramarray_dot3fp;
}

ion::video::Program* DOT3Programs::firstWorkingProgram_dot3fp()
{
	return m_pFirstWorkingProgram_dot3fp;
}

const ion::video::Program* DOT3Programs::firstWorkingProgram_dot3fp() const
{
	return m_pFirstWorkingProgram_dot3fp;
}

