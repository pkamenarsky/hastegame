// Autogenerated from csm_vert.xml
// DO NOT EDIT THIS FILE! Edit csm_vert.xml instead

#include <string>
#include "dot3programs.h"
#include "../video/programarray.hh"

struct Programentry {
	const char* m_Name,*m_Format,*m_Entrypoint,*m_Code;
};

static const Programentry s_Entries_dot3vp[]={
	{"dot3vp_vp","cg_vprogram","main",
" \
float4x4 matWorldViewProjection;  \
float4 vViewPosition; \
float3 lightpos;  \
float2 fogvalues;  \
  \
struct VS_INPUT   \
{  \
   float4 Position : POSITION0;  \
   float3 Normal : NORMAL;  \
   float2 UV : TEXCOORD0; \
   float3 Tangent : TEXCOORD1; \
   float3 Binormal : TEXCOORD2; \
};  \
  \
struct VS_OUTPUT   \
{  \
   float4 Position : POSITION0;  \
   float2 UV : TEXCOORD0;  \
   float4 Lightpos : TEXCOORD1; \
   float4 Vertexpos :  TEXCOORD2; \
   float3 Viewvec : TEXCOORD3; \
   float Fog: FOG;  \
};  \
  \
VS_OUTPUT main( VS_INPUT Input )  \
{ \
   VS_OUTPUT Output; \
  \
   Output.Position = mul( matWorldViewProjection, Input.Position ); \
   Output.Fog = 1.0f-((Output.Position.z-fogvalues.x)/fogvalues.y);  \
   Output.UV = Input.UV; \
    \
   float3x3 normalMat = float3x3(matWorldViewProjection); \
   float3x3 texspace, tangentspace; \
   texspace = float3x3(mul(normalMat, Input.Tangent), mul(normalMat, -Input.Binormal), mul(normalMat, Input.Normal)); \
   tangentspace = float3x3(Input.Tangent, -Input.Binormal, Input.Normal); \
  \
   float3 lightvector = mul(matWorldViewProjection, float4(lightpos, 1)).xyz; \
 \
   Output.Vertexpos = float4(mul(texspace, Output.Position.xyz), length(Output.Position.xyz)); \
   Output.Lightpos.xyz = mul(tangentspace, lightpos.xyz - Input.Position.xyz); \
   Output.Viewvec = mul(tangentspace, vViewPosition.xyz - Input.Position.xyz); \
 \
   /*Output.Lightpos.xyz = mul(texspace, lightvector) - Output.Vertexpos.xyz; */\
   float ll = length(Output.Lightpos.xyz); \
   Output.Lightpos.w = ll; \
 \
   return (Output);  \
} \
"
	},
	{0,0,0,0}
};
//   Output.Lightpos.xyz = mul(texspace, lightvector) - Output.Vertexpos.xyz;

static const Programentry s_Entries_dot3fp[]={
	{"dot3vp_fp","cg_fprogram","main",
" \
sampler2D diffuseTex;  \
sampler2D normalMap; \
float4 colorAndRadius; \
float4 specularColorAndPower; \
void intersect_square_cone_10step (inout float3 dp, float3 ds); \
 \
float4 main(  float2 texCoord:TEXCOORD0,  \
   float4 LightPos : TEXCOORD1, \
   float4 VertexPos :  TEXCOORD2, \
   float3 Viewvec : TEXCOORD3) : COLOR0  \
{ \
   float4 t,c; \
   float3 l,s; \
   float3 pt_eye, pt_light; \
   float a; \
 \
   float3 light_pos = LightPos.xyz; \
   float light_dist = LightPos.w; \
 \
   float3 vertex_pos = VertexPos.xyz; \
   float vertex_dist = VertexPos.w; \
 \
   float depth = 0.05; \
   float texsize = 512; \
 \
   a  = -depth / vertex_pos.z; \
   s = vertex_pos * a; \
   s.z = 1.0; \
   \
   pt_eye = float3(texCoord, 0.0); \
   intersect_square_cone_10step (pt_eye, s); \
   \
   c=tex2D(diffuseTex,pt_eye.xy); \
 \
   t=tex2D(normalMap, pt_eye.xy); \
   t = float4((t.ba-0.5) * (-depth * texsize), 1.0, 0.0); \
/*   t = float4(0, 0, 1, 0);*/ \
   t=normalize(t); \
 \
   float fd=clamp(dot(normalize(light_pos),t.xyz),0,1); \
   float fs=pow(clamp(dot(normalize(normalize(light_pos) + normalize(Viewvec)), t), 0, 1), specularColorAndPower.w); \
   float att=clamp(1.0f-length(light_pos) / colorAndRadius.w,0,1); \
  \
   float as = 0; \
   if(fd > 0) \
      as = 1; \
/*   return (float4((fd * c.xyz * colorAndRadius.xyz + fs * as * specularColorAndPower.xyz) * att, 1.0f)); */ \
   return fd * c; \
} \
"
//   return( float4((fd*colorAndRadius.xyz)*att, 1.0f ) );
" \
void intersect_square_cone_10step (inout float3 dp, float3 ds) \
{ \
   float iz = max(abs(ds.x),abs(ds.y)); \
   float w = 1.2; \
   float4 t; \
 \
   t=tex2D(normalMap, dp.xy); \
   dp += ds * w * (t.r - dp.z) / (iz/(t.g*t.g) + 1.0); \
    \
   t=tex2D(normalMap, dp.xy); \
   dp += ds * w * (t.r - dp.z) / (iz/(t.g*t.g) + 1.0); \
   t=tex2D(normalMap, dp.xy); \
   dp += ds * w * (t.r - dp.z) / (iz/(t.g*t.g) + 1.0); \
   t=tex2D(normalMap, dp.xy); \
   dp += ds * w * (t.r - dp.z) / (iz/(t.g*t.g) + 1.0); \
   t=tex2D(normalMap, dp.xy); \
   dp += ds * w * (t.r - dp.z) / (iz/(t.g*t.g) + 1.0); \
    \
   t=tex2D(normalMap, dp.xy); \
   dp += ds * w * (t.r - dp.z) / (iz/(t.g*t.g) + 1.0); \
   t=tex2D(normalMap, dp.xy); \
   dp += ds * w * (t.r - dp.z) / (iz/(t.g*t.g) + 1.0); \
   t=tex2D(normalMap, dp.xy); \
   dp += ds * w * (t.r - dp.z) / (iz/(t.g*t.g) + 1.0); \
   t=tex2D(normalMap, dp.xy); \
   dp += ds * w * (t.r - dp.z) / (iz/(t.g*t.g) + 1.0); \
   t=tex2D(normalMap, dp.xy); \
   dp += ds * w * (t.r - dp.z) / (iz/(t.g*t.g) + 1.0); \
} \
 \
"
	},
	{0,0,0,0}
};

DOT3Programs::DOT3Programs(ion::video::Videodevice &rVideodevice)
{
	m_pProgramarray_dot3vp=new ion::video::Programarray(rVideodevice,ion::video::Programarray::Vertexprograms);
	{
		const Programentry* pEntry=&s_Entries_dot3vp[0];
		for (;pEntry->m_Name!=0;++pEntry) {
			m_pProgramarray_dot3vp->addProgram(pEntry->m_Name,pEntry->m_Entrypoint,pEntry->m_Code,pEntry->m_Format);
		}
	}
	m_pFirstWorkingProgram_dot3vp=m_pProgramarray_dot3vp->getFirstValidProgram();

	m_pProgramarray_dot3fp=new ion::video::Programarray(rVideodevice,ion::video::Programarray::Fragmentprograms);
	{
		const Programentry* pEntry=&s_Entries_dot3fp[0];
		for (;pEntry->m_Name!=0;++pEntry) {
			m_pProgramarray_dot3fp->addProgram(pEntry->m_Name,pEntry->m_Entrypoint,pEntry->m_Code,pEntry->m_Format);
		}
	}
	m_pFirstWorkingProgram_dot3fp=m_pProgramarray_dot3fp->getFirstValidProgram();

}

DOT3Programs::~DOT3Programs()
{
	delete m_pProgramarray_dot3vp;
	delete m_pProgramarray_dot3fp;
}


DOT3Programs::DOT3Programs(const DOT3Programs& src) {}
DOT3Programs& DOT3Programs::operator =(const DOT3Programs& src) { return *this; }

ion::video::Programarray& DOT3Programs::programarray_dot3vp()
{
	return *m_pProgramarray_dot3vp;
}

const ion::video::Programarray& DOT3Programs::programarray_dot3vp() const
{
	return *m_pProgramarray_dot3vp;
}

ion::video::Program* DOT3Programs::firstWorkingProgram_dot3vp()
{
	return m_pFirstWorkingProgram_dot3vp;
}

const ion::video::Program* DOT3Programs::firstWorkingProgram_dot3vp() const
{
	return m_pFirstWorkingProgram_dot3vp;
}

ion::video::Programarray& DOT3Programs::programarray_dot3fp()
{
	return *m_pProgramarray_dot3fp;
}

const ion::video::Programarray& DOT3Programs::programarray_dot3fp() const
{
	return *m_pProgramarray_dot3fp;
}

ion::video::Program* DOT3Programs::firstWorkingProgram_dot3fp()
{
	return m_pFirstWorkingProgram_dot3fp;
}

const ion::video::Program* DOT3Programs::firstWorkingProgram_dot3fp() const
{
	return m_pFirstWorkingProgram_dot3fp;
}

